// Date: 13/06/2014 17:30:09
// Template version 1.1
// Java generated by Techne
// Keep in mind that you still need to fill in some blanks
// - ZeuX






package common.cout970.UltraTech.models;

import org.lwjgl.opengl.GL11;

import api.cout970.UltraTech.fluids.FluidUtils;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;

public class ModelPipe extends ModelBase
{
  //fields
    ModelRenderer partD;
    ModelRenderer hookD;
    ModelRenderer partU;
    ModelRenderer hookU;
    ModelRenderer partF;
    ModelRenderer hookF;
    ModelRenderer partL;
    ModelRenderer hookL;
    ModelRenderer partB;
    ModelRenderer hookB;
    ModelRenderer partR;
    ModelRenderer hookR;
    ModelRenderer BaseD;
    ModelRenderer BaseU;
    ModelRenderer baseF;
    ModelRenderer baseL;
    ModelRenderer baseB;
    ModelRenderer baseR;
  
  public ModelPipe()
  {
    textureWidth = 64;
    textureHeight = 32;
    
      partD = new ModelRenderer(this, 0, 23);
      partD.addBox(-3F, 3F, -3F, 6, 3, 6);
      partD.setRotationPoint(0F, 16F, 0F);
      partD.setTextureSize(64, 32);
      partD.mirror = true;
      setRotation(partD, 0F, 0F, 0F);
      hookD = new ModelRenderer(this, 0, 13);
      hookD.addBox(-4F, 6F, -4F, 8, 2, 8);
      hookD.setRotationPoint(0F, 16F, 0F);
      hookD.setTextureSize(64, 32);
      hookD.mirror = true;
      setRotation(hookD, 0F, 0F, 0F);
      partU = new ModelRenderer(this, 0, 23);
      partU.addBox(-3F, -6F, -3F, 6, 3, 6);
      partU.setRotationPoint(0F, 16F, 0F);
      partU.setTextureSize(64, 32);
      partU.mirror = true;
      setRotation(partU, 0F, 0F, 0F);
      hookU = new ModelRenderer(this, 0, 13);
      hookU.addBox(-4F, -8F, -4F, 8, 2, 8);
      hookU.setRotationPoint(0F, 16F, 0F);
      hookU.setTextureSize(64, 32);
      hookU.mirror = true;
      setRotation(hookU, 0F, 0F, 0F);
      partF = new ModelRenderer(this, 24, 23);
      partF.addBox(-3F, -3F, -6F, 6, 6, 3);
      partF.setRotationPoint(0F, 16F, 0F);
      partF.setTextureSize(64, 32);
      partF.mirror = true;
      setRotation(partF, 0F, 0F, 0F);
      hookF = new ModelRenderer(this, 24, 0);
      hookF.addBox(-4F, -4F, -8F, 8, 8, 2);
      hookF.setRotationPoint(0F, 16F, 0F);
      hookF.setTextureSize(64, 32);
      hookF.mirror = true;
      setRotation(hookF, 0F, 0F, 0F);
      partL = new ModelRenderer(this, 42, 20);
      partL.addBox(3F, -3F, -3F, 3, 6, 6);
      partL.setRotationPoint(0F, 16F, 0F);
      partL.setTextureSize(64, 32);
      partL.mirror = true;
      setRotation(partL, 0F, 0F, 0F);
      hookL = new ModelRenderer(this, 44, 0);
      hookL.addBox(6F, -4F, -4F, 2, 8, 8);
      hookL.setRotationPoint(0F, 16F, 0F);
      hookL.setTextureSize(64, 32);
      hookL.mirror = true;
      setRotation(hookL, 0F, 0F, 0F);
      partB = new ModelRenderer(this, 24, 23);
      partB.addBox(-3F, -3F, 3F, 6, 6, 3);
      partB.setRotationPoint(0F, 16F, 0F);
      partB.setTextureSize(64, 32);
      partB.mirror = true;
      setRotation(partB, 0F, 0F, 0F);
      hookB = new ModelRenderer(this, 24, 0);
      hookB.addBox(-4F, -4F, 6F, 8, 8, 2);
      hookB.setRotationPoint(0F, 16F, 0F);
      hookB.setTextureSize(64, 32);
      hookB.mirror = true;
      setRotation(hookB, 0F, 0F, 0F);
      partR = new ModelRenderer(this, 42, 20);
      partR.addBox(-6F, -3F, -3F, 3, 6, 6);
      partR.setRotationPoint(0F, 16F, 0F);
      partR.setTextureSize(64, 32);
      partR.mirror = true;
      setRotation(partR, 0F, 0F, 0F);
      hookR = new ModelRenderer(this, 44, 0);
      hookR.addBox(-8F, -4F, -4F, 2, 8, 8);
      hookR.setRotationPoint(0F, 16F, 0F);
      hookR.setTextureSize(64, 32);
      hookR.mirror = true;
      setRotation(hookR, 0F, 0F, 0F);
      BaseD = new ModelRenderer(this, 0, 0);
      BaseD.addBox(-3F, 3F, -3F, 6, 0, 6);
      BaseD.setRotationPoint(0F, 16F, 0F);
      BaseD.setTextureSize(64, 32);
      BaseD.mirror = true;
      setRotation(BaseD, 0F, 0F, 0F);
      BaseU = new ModelRenderer(this, 0, 0);
      BaseU.addBox(-3F, -3F, -3F, 6, 0, 6);
      BaseU.setRotationPoint(0F, 16F, 0F);
      BaseU.setTextureSize(64, 32);
      BaseU.mirror = true;
      setRotation(BaseU, 0F, 0F, 0F);
      baseF = new ModelRenderer(this, 0, 0);
      baseF.addBox(-3F, -3F, -3F, 6, 6, 0);
      baseF.setRotationPoint(0F, 16F, 0F);
      baseF.setTextureSize(64, 32);
      baseF.mirror = true;
      setRotation(baseF, 0F, (float) Math.PI, 0F);//changeg 0 => Math.pi
      baseL = new ModelRenderer(this, 0, 0);
      baseL.addBox(3F, -3F, -3F, 0, 6, 6);
      baseL.setRotationPoint(0F, 16F, 0F);
      baseL.setTextureSize(64, 32);
      baseL.mirror = true;
      setRotation(baseL, 0F, 0F, 0F);
      baseB = new ModelRenderer(this, 0, 0);
      baseB.addBox(-3F, -3F, 3F, 6, 6, 0);
      baseB.setRotationPoint(0F, 16F, 0F);
      baseB.setTextureSize(64, 32);
      baseB.mirror = true;
      setRotation(baseB, 0F, 0F, 0F);
      baseR = new ModelRenderer(this, 0, 0);
      baseR.addBox(-3F, -3F, -3F, 0, 6, 6);
      baseR.setRotationPoint(0F, 16F, 0F);
      baseR.setTextureSize(64, 32);
      baseR.mirror = true;
      setRotation(baseR, 0F, 0F, 0F);
  }
  
  public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
  {
    super.render(entity, f, f1, f2, f3, f4, f5);
    setRotationAngles(f, f1, f2, f3, f4, f5, entity);
    partD.render(f5);
    hookD.render(f5);
    partU.render(f5);
    hookU.render(f5);
    partF.render(f5);
    hookF.render(f5);
    partL.render(f5);
    hookL.render(f5);
    partB.render(f5);
    hookB.render(f5);
    partR.render(f5);
    hookR.render(f5);
    BaseD.render(f5);
    BaseU.render(f5);
    baseF.render(f5);
    baseL.render(f5);
    baseB.render(f5);
    baseR.render(f5);
  }
  
  private void setRotation(ModelRenderer model, float x, float y, float z)
  {
    model.rotateAngleX = x;
    model.rotateAngleY = y;
    model.rotateAngleZ = z;
  }
  
  public void setRotationAngles(float f, float f1, float f2, float f3, float f4, float f5, Entity entity)
  {
    super.setRotationAngles(f, f1, f2, f3, f4, f5, entity);
  }

  public void renderModel(float f5, IBlockAccess w, int x, int y, int z) {
		
	boolean renderUp = FluidUtils.CanPassFluid(
			w.getTileEntity(x, y, z),
			w.getTileEntity(x, y + 1, z));
	boolean renderDown = FluidUtils.CanPassFluid(
			w.getTileEntity(x, y, z),
			w.getTileEntity(x, y - 1, z));
	boolean renderFront = FluidUtils.CanPassFluid(
			w.getTileEntity(x, y, z),
			w.getTileEntity(x, y, z + 1));
	boolean renderBack = FluidUtils.CanPassFluid(
			w.getTileEntity(x, y, z),
			w.getTileEntity(x, y, z - 1));
	boolean renderRight = FluidUtils.CanPassFluid(
			w.getTileEntity(x, y, z),
			w.getTileEntity(x + 1, y, z));
	boolean renderLeft = FluidUtils.CanPassFluid(
			w.getTileEntity(x, y, z),
			w.getTileEntity(x - 1, y, z));
	
	if(renderRight){
		partR.render(f5);
		hookR.render(f5);
	}else{baseR.render(f5);}
	if(renderLeft){
		partL.render(f5);
		hookL.render(f5);
	}else{baseL.render(f5);}
	if(renderBack){
		partF.render(f5);
		hookF.render(f5);
	}else{
		GL11.glPushMatrix();
		GL11.glRotatef(90, 0, 1, 0);
		baseL.render(f5);
		GL11.glPopMatrix();
	}
	if(renderFront){
		partB.render(f5);
		hookB.render(f5);
	}else{
		GL11.glPushMatrix();
		GL11.glRotatef(-90, 0, 1, 0);
		baseL.render(f5);
		GL11.glPopMatrix();
		}
	if(renderUp){
		partU.render(f5);
		hookU.render(f5);
	}else{BaseU.render(f5);}
	if(renderDown){
		partD.render(f5);
		hookD.render(f5);
	}else{BaseD.render(f5);}
	
}

}
